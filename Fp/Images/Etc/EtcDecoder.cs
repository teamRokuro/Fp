/*
Copyright (c) 2015 Harm Hanemaaijer <fgenfb@yahoo.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

using System;
using System.Buffers.Binary;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Fp.Images.Etc;

#pragma warning disable 1591

namespace Fp.Images.Etc
{
    [SuppressMessage("ReSharper", "UnusedMember.Local")]
    [SuppressMessage("ReSharper", "IdentifierTypo")]
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    [SuppressMessage("ReSharper", "UnusedParameter.Global")]
    [SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
    public static class EtcDecoder
    {
        [Flags]
        public enum EtcMode : uint
        {
            EtcIndividual = 0x1,
            EtcDifferential = 0x2,
            EtcT = 0x4,
            EtcH = 0x8,
            EtcPlanar = 0x10,
            AllModesEtc1 = 0x3,
            AllModesEtc2 = 0x1F,
            AllModesEtc2Punchthrough = 0X1E,
            All = 0XFFFFFFFF
        }

        [Flags]
        public enum DecompressionFunctionFlags
        {
            None = 0x0,

            /// <summary>
            /// Function returns false (invalid block) when the compressed block
            /// is in a format not allowed to be generated by an encoder.
            /// </summary>
            Encode = 0x1,

            /// <summary>
            /// For compression formats that have opaque and non-opaque modes,
            /// return false (invalid block) when the compressed block is encoded
            /// using a non-opaque mode.
            /// </summary>
            OpaqueOnly = 0x2,

            /// <summary>
            /// For compression formats that have opaque and non-opaque modes,
            /// return false (invalid block) when the compressed block is encoded
            /// using an opaque mode.
            /// </summary>
            NonOpaqueOnly = 0x4
        }

        private static readonly int[] Complement3BitshiftedTable = {0, 8, 16, 24, -32, -24, -16, -8};

        private static readonly int[] ModifierTable =
        {
            2, 8, -2, -8, 5, 17, -5, -17, 9, 29, -9, -29, 13, 42, -13, -42, 18, 60, -18, -60, 24, 80, -24, -80, 33,
            106, -33, -106, 47, 183, -47, -183
        };

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int Clamp2047(int x)
        {
            if (x < 0)
                return 0;
            if (x > 2047)
                return 2047;
            return x;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int clamp1023_signed(int x)
        {
            if (x < -1023)
                return -1023;
            if (x > 1023)
                return 1023;
            return x;
        }

        /// <summary>
        /// This function calculates the 3-bit complement value in the range -4 to 3 of a three bit representation. The result is arithmetically shifted 3 places to the left before returning.
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int Complement3Bitshifted(int x)
        {
            return Complement3BitshiftedTable[x];
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int complement3bitshifted_slow(int x)
        {
            if ((x & 4) != 0)
                return ((x & 3) - 4) << 3; // Note: shift is arithmetic.
            return x << 3;
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int Complement3Bit(int x)
        {
            if ((x & 4) != 0)
                return (x & 3) - 4;
            return x;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static byte Clamp(int x) => (byte)(x < 0 ? 0 : x > 255 ? 255 : x);

        private static uint Rgba(byte r, byte g, byte b, byte a)
        {
            return BitConverter.IsLittleEndian
                ? (uint)(r | (g << 8) | (b << 16) | (a << 24))
                : (uint)((r << 24) | (g << 16) | (b << 8) | a);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void ProcessPixelEtc1(byte i, uint pixelIndexWord,
            // Define inline function to speed up ETC1 decoding.
            uint tableCodeword, int* baseColorSubblock,
            byte* pixelBuffer)
        {
            int pixelIndex = (int)(((pixelIndexWord & (1 << i)) >> i)
                                   | ((pixelIndexWord & (0x10000 << i)) >> (16 + i - 1)));
            int modifier = ModifierTable[4 * tableCodeword + pixelIndex];
            byte r = Clamp(baseColorSubblock[0] + modifier);
            byte g = Clamp(baseColorSubblock[1] + modifier);
            byte b = Clamp(baseColorSubblock[2] + modifier);
            uint* buffer = (uint*)pixelBuffer;
            buffer[(i & 3) * 4 + ((i & 12) >> 2)] = Rgba(r, g, b, 0xff);
        }

        /// <summary>
        /// Decompress a 64-bit 4x4 pixel texture block compressed using the ETC1 format.
        /// </summary>
        /// <param name="bitString"></param>
        /// <param name="etc"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEtc1(byte* bitString, EtcMode etc,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            int differentialMode = bitString[3] & 2;
            if (differentialMode != 0)
            {
                if ((etc & EtcMode.EtcDifferential) == 0)
                    return false;
            }
            else if ((etc & EtcMode.EtcIndividual) == 0)
                return false;

            int flipbit = bitString[3] & 1;
            int* baseColorSubblock1 = stackalloc int[3];
            int* baseColorSubblock2 = stackalloc int[3];
            if (differentialMode != 0)
            {
                baseColorSubblock1[0] = bitString[0] & 0xF8;
                baseColorSubblock1[0] |= (baseColorSubblock1[0] & 224) >> 5;
                baseColorSubblock1[1] = bitString[1] & 0xF8;
                baseColorSubblock1[1] |= (baseColorSubblock1[1] & 224) >> 5;
                baseColorSubblock1[2] = bitString[2] & 0xF8;
                baseColorSubblock1[2] |= (baseColorSubblock1[2] & 224) >> 5;
                baseColorSubblock2[0] = bitString[0] & 0xF8; // 5 highest order bits.
                baseColorSubblock2[0] += Complement3Bitshifted(bitString[0] & 7); // Add difference.
                if ((baseColorSubblock2[0] & 0xFF07) != 0) // Check for overflow.
                    return false;
                baseColorSubblock2[0] |= (baseColorSubblock2[0] & 224) >> 5; // Replicate.
                baseColorSubblock2[1] = bitString[1] & 0xF8;
                baseColorSubblock2[1] += Complement3Bitshifted(bitString[1] & 7);
                if ((baseColorSubblock2[1] & 0xFF07) != 0)
                    return false;
                baseColorSubblock2[1] |= (baseColorSubblock2[1] & 224) >> 5;
                baseColorSubblock2[2] = bitString[2] & 0xF8;
                baseColorSubblock2[2] += Complement3Bitshifted(bitString[2] & 7);
                if ((baseColorSubblock2[2] & 0xFF07) != 0)
                    return false;
                baseColorSubblock2[2] |= (baseColorSubblock2[2] & 224) >> 5;
            }
            else
            {
                baseColorSubblock1[0] = bitString[0] & 0xF0;
                baseColorSubblock1[0] |= baseColorSubblock1[0] >> 4;
                baseColorSubblock1[1] = bitString[1] & 0xF0;
                baseColorSubblock1[1] |= baseColorSubblock1[1] >> 4;
                baseColorSubblock1[2] = bitString[2] & 0xF0;
                baseColorSubblock1[2] |= baseColorSubblock1[2] >> 4;
                baseColorSubblock2[0] = bitString[0] & 0x0F;
                baseColorSubblock2[0] |= baseColorSubblock2[0] << 4;
                baseColorSubblock2[1] = bitString[1] & 0x0F;
                baseColorSubblock2[1] |= baseColorSubblock2[1] << 4;
                baseColorSubblock2[2] = bitString[2] & 0x0F;
                baseColorSubblock2[2] |= baseColorSubblock2[2] << 4;
            }

            uint tableCodeword1 = (uint)((bitString[3] & 224) >> 5);
            uint tableCodeword2 = (uint)((bitString[3] & 28) >> 2);
            uint pixelIndexWord = ((uint)bitString[4] << 24) | ((uint)bitString[5] << 16) |
                                  ((uint)bitString[6] << 8) | bitString[7];
            if (flipbit == 0)
            {
                ProcessPixelEtc1(0, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(1, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(2, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(3, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(4, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(5, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(6, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(7, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(8, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(9, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(10, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(11, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(12, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(13, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(14, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(15, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
            }
            else
            {
                ProcessPixelEtc1(0, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(1, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(2, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(3, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(4, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(5, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(6, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(7, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(8, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(9, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(10, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(11, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(12, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(13, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc1(14, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc1(15, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
            }

            return true;
        }

        /// <summary>
        /// Return the internal mode of a ETC1 block.
        /// </summary>
        /// <param name="bitString"></param>
        /// <returns></returns>
        public static unsafe EtcMode GetModeEtc1(byte* bitString)
        {
            // Figure out the mode.
            return (bitString[3] & 2) == 0
                ? EtcMode.EtcIndividual
                : EtcMode.EtcDifferential;
        }

        public static unsafe void SetModeEtc1(byte* bitString, EtcMode etcMode,
            DecompressionFunctionFlags flags)
        {
            if ((etcMode & EtcMode.EtcIndividual) == EtcMode.EtcIndividual)
                bitString[3] &= unchecked((byte)~0x2);
            else
                bitString[3] |= 0x2;
        }

        private static readonly int[] Etc2DistanceTable = {3, 6, 11, 16, 23, 32, 41, 64};

        private static unsafe void ProcessBlockEtc2TOrHMode(byte* bitString, EtcMode etcMode,
            byte* pixelBuffer)
        {
            int baseColor1R, baseColor1G, baseColor1B;
            int baseColor2R, baseColor2G, baseColor2B;
            int* paintColorR = stackalloc int[4],
                paintColorG = stackalloc int[4],
                paintColorB = stackalloc int[4];

            int distance;
            if (etcMode == EtcMode.EtcT)
            {
                // T mode.
                baseColor1R = ((bitString[0] & 0x18) >> 1) | (bitString[0] & 0x3);
                baseColor1R |= baseColor1R << 4;
                baseColor1G = bitString[1] & 0xF0;
                baseColor1G |= baseColor1G >> 4;
                baseColor1B = bitString[1] & 0x0F;
                baseColor1B |= baseColor1B << 4;
                baseColor2R = bitString[2] & 0xF0;
                baseColor2R |= baseColor2R >> 4;
                baseColor2G = bitString[2] & 0x0F;
                baseColor2G |= baseColor2G << 4;
                baseColor2B = bitString[3] & 0xF0;
                baseColor2B |= baseColor2B >> 4;
                // index = (da << 1) | db
                distance = Etc2DistanceTable[((bitString[3] & 0x0C) >> 1) | (bitString[3] & 0x1)];
                paintColorR[0] = baseColor1R;
                paintColorG[0] = baseColor1G;
                paintColorB[0] = baseColor1B;
                paintColorR[2] = baseColor2R;
                paintColorG[2] = baseColor2G;
                paintColorB[2] = baseColor2B;
                paintColorR[1] = Clamp(baseColor2R + distance);
                paintColorG[1] = Clamp(baseColor2G + distance);
                paintColorB[1] = Clamp(baseColor2B + distance);
                paintColorR[3] = Clamp(baseColor2R - distance);
                paintColorG[3] = Clamp(baseColor2G - distance);
                paintColorB[3] = Clamp(baseColor2B - distance);
            }
            else
            {
                // H mode.
                baseColor1R = (bitString[0] & 0x78) >> 3;
                baseColor1R |= baseColor1R << 4;
                baseColor1G = ((bitString[0] & 0x07) << 1) | ((bitString[1] & 0x10) >> 4);
                baseColor1G |= baseColor1G << 4;
                baseColor1B = (bitString[1] & 0x08) | ((bitString[1] & 0x03) << 1) | ((bitString[2] & 0x80) >> 7);
                baseColor1B |= baseColor1B << 4;
                baseColor2R = (bitString[2] & 0x78) >> 3;
                baseColor2R |= baseColor2R << 4;
                baseColor2G = ((bitString[2] & 0x07) << 1) | ((bitString[3] & 0x80) >> 7);
                baseColor2G |= baseColor2G << 4;
                baseColor2B = (bitString[3] & 0x78) >> 3;
                baseColor2B |= baseColor2B << 4;
                // da is most significant bit, db is middle bit, least significant bit is
                // (base_color1 value >= base_color2 value).
                int baseColor1Value = (baseColor1R << 16) + (baseColor1G << 8) + baseColor1B;
                int baseColor2Value = (baseColor2R << 16) + (baseColor2G << 8) + baseColor2B;
                int bit = baseColor1Value >= baseColor2Value ? 1 : 0;
                distance = Etc2DistanceTable[(bitString[3] & 0x04) | ((bitString[3] & 0x01) << 1) | bit];
                paintColorR[0] = Clamp(baseColor1R + distance);
                paintColorG[0] = Clamp(baseColor1G + distance);
                paintColorB[0] = Clamp(baseColor1B + distance);
                paintColorR[1] = Clamp(baseColor1R - distance);
                paintColorG[1] = Clamp(baseColor1G - distance);
                paintColorB[1] = Clamp(baseColor1B - distance);
                paintColorR[2] = Clamp(baseColor2R + distance);
                paintColorG[2] = Clamp(baseColor2G + distance);
                paintColorB[2] = Clamp(baseColor2B + distance);
                paintColorR[3] = Clamp(baseColor2R - distance);
                paintColorG[3] = Clamp(baseColor2G - distance);
                paintColorB[3] = Clamp(baseColor2B - distance);
            }

            uint pixelIndexWord = ((uint)bitString[4] << 24) | ((uint)bitString[5] << 16) |
                                  ((uint)bitString[6] << 8) | bitString[7];

            uint* buffer = (uint*)pixelBuffer;
            for (int i = 0; i < 16; i++)
            {
                int pixelIndex = (int)((pixelIndexWord & (1 << i)) >> i); // Least significant bit.
                pixelIndex |= (int)((pixelIndexWord & (0x10000 << i)) >> (16 + i - 1)); // Most significant bit.
                int r = paintColorR[pixelIndex];
                int g = paintColorG[pixelIndex];
                int b = paintColorB[pixelIndex];
                buffer[(i & 3) * 4 + ((i & 12) >> 2)] = Rgba((byte)r, (byte)g, (byte)b, 0xff);
            }
        }

        private static unsafe void ProcessBlockEtc2PlanarMode(byte* bitString,
            byte* pixelBuffer)
        {
            // Each color O, H and V is in 6-7-6 format.
            int ro = (bitString[0] & 0x7E) >> 1;
            int go = ((bitString[0] & 0x1) << 6) | ((bitString[1] & 0x7E) >> 1);

            int bo = ((bitString[1] & 0x1) << 5) | (bitString[2] & 0x18) | ((bitString[2] & 0x03) << 1) |
                     ((bitString[3] & 0x80) >> 7);

            int rh = ((bitString[3] & 0x7C) >> 1) | (bitString[3] & 0x1);
            int gh = (bitString[4] & 0xFE) >> 1;
            int bh = ((bitString[4] & 0x1) << 5) | ((bitString[5] & 0xF8) >> 3);
            int rv = ((bitString[5] & 0x7) << 3) | ((bitString[6] & 0xE0) >> 5);
            int gv = ((bitString[6] & 0x1F) << 2) | ((bitString[7] & 0xC0) >> 6);
            int bv = bitString[7] & 0x3F;
            ro = (ro << 2) | ((ro & 0x30) >> 4); // Replicate bits.
            go = (go << 1) | ((go & 0x40) >> 6);
            bo = (bo << 2) | ((bo & 0x30) >> 4);
            rh = (rh << 2) | ((rh & 0x30) >> 4);
            gh = (gh << 1) | ((gh & 0x40) >> 6);
            bh = (bh << 2) | ((bh & 0x30) >> 4);
            rv = (rv << 2) | ((rv & 0x30) >> 4);
            gv = (gv << 1) | ((gv & 0x40) >> 6);
            bv = (bv << 2) | ((bv & 0x30) >> 4);

            uint* buffer = (uint*)pixelBuffer;
            for (int y = 0; y < 4; y++)
            for (int x = 0; x < 4; x++)
            {
                byte r = Clamp((x * (rh - ro) + y * (rv - ro) + 4 * ro + 2) >> 2);
                byte g = Clamp((x * (gh - go) + y * (gv - go) + 4 * go + 2) >> 2);
                byte b = Clamp((x * (bh - bo) + y * (bv - bo) + 4 * bo + 2) >> 2);
                buffer[y * 4 + x] = Rgba(r, g, b, 0xff);
            }
        }

        /// <summary>
        /// Decompress a 64-bit 4x4 pixel texture block compressed using the ETC2 format.
        /// </summary>
        /// <param name="bitString"></param>
        /// <param name="etc"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEtc2(byte* bitString, EtcMode etc,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            // Figure out the mode.
            if ((bitString[3] & 2) == 0)
            {
                // Individual mode.
                return DecompressBlockEtc1(bitString, etc, flags,
                    pixelBuffer);
            }

            if ((etc & ~EtcMode.EtcIndividual) == 0)
                return false;
            int r = bitString[0] & 0xF8;
            r += Complement3Bitshifted(bitString[0] & 7);
            int g = bitString[1] & 0xF8;
            g += Complement3Bitshifted(bitString[1] & 7);
            int b = bitString[2] & 0xF8;
            b += Complement3Bitshifted(bitString[2] & 7);
            if ((r & 0xFF07) != 0)
            {
                // T mode.
                if ((etc & EtcMode.EtcT) == 0)
                    return false;

                ProcessBlockEtc2TOrHMode(bitString, EtcMode.EtcT,
                    pixelBuffer);
                return true;
            }

            if ((g & 0xFF07) != 0)
            {
                // H mode.
                if ((etc & EtcMode.EtcH) == 0)
                    return false;

                ProcessBlockEtc2TOrHMode(bitString, EtcMode.EtcH,
                    pixelBuffer);
                return true;
            }

            if ((b & 0xFF07) != 0)
            {
                // Planar mode.
                if ((etc & EtcMode.EtcPlanar) == 0)
                    return false;

                ProcessBlockEtc2PlanarMode(bitString, pixelBuffer);
                return true;
            }

            // Differential mode.
            return DecompressBlockEtc1(bitString, etc, flags,
                pixelBuffer);
        }

        /// <summary>
        /// Return the internal mode of a ETC2 block.
        /// </summary>
        /// <param name="bitString"></param>
        /// <returns></returns>
        public static unsafe EtcMode GetModeEtc2(byte* bitString)
        {
            if ((bitString[3] & 2) == 0)
                return EtcMode.EtcIndividual;

            int r = bitString[0] & 0xF8;
            r += Complement3Bitshifted(bitString[0] & 7);
            int g = bitString[1] & 0xF8;
            g += Complement3Bitshifted(bitString[1] & 7);
            int b = bitString[2] & 0xF8;
            b += Complement3Bitshifted(bitString[2] & 7);
            if ((r & 0xFF07) != 0)
                return EtcMode.EtcT;
            if ((g & 0xFF07) != 0)
                return EtcMode.EtcH;
            if ((b & 0xFF07) != 0)
                return EtcMode.EtcPlanar;
            return EtcMode.EtcDifferential;
        }

        public static unsafe void SetModeEtc2Thp(byte* bitString, EtcMode etcMode,
            DecompressionFunctionFlags flags)
        {
            if (etcMode == EtcMode.EtcDifferential)
            {
                // bitString[0] bits 0, 1, 3, 4 are used.
                // Bits 2, 5, 6, 7 can be modified.
                // Modify bits 2, 5, 6, 7 so that R < 0 or R > 31.
                int rBits5To7Clear = (bitString[0] & 0x18) >> 3;
                int rComplBit2Clear = Complement3Bit(bitString[0] & 0x3);
                if (rBits5To7Clear + 0x1C + rComplBit2Clear > 31)
                {
                    // Set bits 5, 6, 7 and clear bit 2.
                    bitString[0] &= unchecked((byte)~0x04);
                    bitString[0] |= 0xE0;
                }
                else
                {
                    int rComplBit2Set = Complement3Bit((bitString[0] & 0x3) | 0x4);
                    if (rBits5To7Clear + rComplBit2Set < 0)
                    {
                        // Clear bits 5, 6, 7 and set bit 2.
                        bitString[0] &= unchecked((byte)~0xE0);
                        bitString[0] |= 0x04;
                    }
                }
            }

            else if (etcMode == EtcMode.AllModesEtc1)
            {
                int gBits5To7Clear = (bitString[1] & 0x18) >> 3;
                int gComplBit2Clear = Complement3Bit(bitString[1] & 0x3);
                if (gBits5To7Clear + 0x1C + gComplBit2Clear > 31)
                {
                    // Set bits 5, 6, 7 and clear bit 2.
                    bitString[1] &= unchecked((byte)~0x04);
                    bitString[1] |= 0xE0;
                }
                else
                {
                    int gComplBit2Set = Complement3Bit((bitString[1] & 0x3) | 0x4);
                    if (gBits5To7Clear + gComplBit2Set < 0)
                    {
                        // Clear bits 5, 6, 7 and set bit 2.
                        bitString[1] &= unchecked((byte)~0xE0);
                        bitString[1] |= 0x04;
                    }
                }
            }

            else if (etcMode == EtcMode.EtcT)
            {
                int bBits5To7Clear = (bitString[2] & 0x18) >> 3;
                int bComplBit2Clear = Complement3Bit(bitString[2] & 0x3);
                if (bBits5To7Clear + 0x1C + bComplBit2Clear > 31)
                {
                    // Set bits 5, 6, 7 and clear bit 2.
                    bitString[2] &= unchecked((byte)~0x04);
                    bitString[2] |= 0xE0;
                }
                else
                {
                    int bComplBit2Set = Complement3Bit((bitString[2] & 0x3) | 0x4);
                    if (bBits5To7Clear + bComplBit2Set < 0)
                    {
                        // Clear bits 5, 6, 7 and set bit 2.
                        bitString[2] &= unchecked((byte)~0xE0);
                        bitString[2] |= 0x04;
                    }
                }
            }
        }

        public static unsafe void SetModeEtc2(byte* bitString, EtcMode etcMode,
            DecompressionFunctionFlags flags)
        {
            if (etcMode == 0)
                // Set Individual mode.
                bitString[3] &= unchecked((byte)~0x2);
            else
            {
                // Set Differential, T, H or P mode.
                bitString[3] |= 0x2;
                SetModeEtc2Thp(bitString, etcMode, flags);
            }
        }

        private static readonly int[,] PunchthroughModifierTable =
        {
            {0, 8, 0, -8}, {0, 17, 0, -17}, {0, 29, 0, -29}, {0, 42, 0, -42}, {0, 60, 0, -60}, {0, 80, 0, -80},
            {0, 106, 0, -106}, {0, 183, 0, -183}
        };

        private static readonly uint[] PunchthroughMaskTable = {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF};

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void ProcessPixelEtc2Punchthrough(byte i,
            uint pixelIndexWord, uint tableCodeword,
            int* baseColorSubblock, byte* pixelBuffer)
        {
            int pixelIndex = (int)(((pixelIndexWord & (1 << i)) >> i)
                                   | ((pixelIndexWord & (0x10000 << i)) >> (16 + i - 1)));

            int modifier = PunchthroughModifierTable[tableCodeword, pixelIndex];
            byte r = Clamp(baseColorSubblock[0] + modifier);
            byte g = Clamp(baseColorSubblock[1] + modifier);
            byte b = Clamp(baseColorSubblock[2] + modifier);
            uint mask = PunchthroughMaskTable[pixelIndex];
            uint* buffer = (uint*)pixelBuffer;
            buffer[(i & 3) * 4 + ((i & 12) >> 2)] =
                Rgba(r, g, b, 0xff) & (BitConverter.IsLittleEndian ? mask : BinaryPrimitives.ReverseEndianness(mask));
        }


        private static unsafe void ProcessBlockEtc2PunchthroughDifferentialMode(byte* bitString,
            byte* pixelBuffer)
        {
            int flipbit = bitString[3] & 1;
            int* baseColorSubblock1 = stackalloc int[3];
            int* baseColorSubblock2 = stackalloc int[3];
            baseColorSubblock1[0] = bitString[0] & 0xF8;
            baseColorSubblock1[0] |= (baseColorSubblock1[0] & 224) >> 5;
            baseColorSubblock1[1] = bitString[1] & 0xF8;
            baseColorSubblock1[1] |= (baseColorSubblock1[1] & 224) >> 5;
            baseColorSubblock1[2] = bitString[2] & 0xF8;
            baseColorSubblock1[2] |= (baseColorSubblock1[2] & 224) >> 5;
            baseColorSubblock2[0] = bitString[0] & 0xF8; // 5 highest order bits.
            baseColorSubblock2[0] += Complement3Bitshifted(bitString[0] & 7); // Add difference.
            baseColorSubblock2[0] |= (baseColorSubblock2[0] & 224) >> 5; // Replicate.
            baseColorSubblock2[1] = bitString[1] & 0xF8;
            baseColorSubblock2[1] += Complement3Bitshifted(bitString[1] & 7);
            baseColorSubblock2[1] |= (baseColorSubblock2[1] & 224) >> 5;
            baseColorSubblock2[2] = bitString[2] & 0xF8;
            baseColorSubblock2[2] += Complement3Bitshifted(bitString[2] & 7);
            baseColorSubblock2[2] |= (baseColorSubblock2[2] & 224) >> 5;
            uint tableCodeword1 = (uint)((bitString[3] & 224) >> 5);
            uint tableCodeword2 = (uint)((bitString[3] & 28) >> 2);

            uint pixelIndexWord = ((uint)bitString[4] << 24) | ((uint)bitString[5] << 16) |
                                  ((uint)bitString[6] << 8) | bitString[7];
            if (flipbit == 0)
            {
                ProcessPixelEtc2Punchthrough(0, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(1, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(2, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(3, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(4, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(5, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(6, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(7, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(8, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(9, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(10, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(11, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(12, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(13, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(14, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(15, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
            }

            else
            {
                ProcessPixelEtc2Punchthrough(0, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(1, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(2, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(3, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(4, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(5, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(6, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(7, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(8, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(9, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(10, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(11, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(12, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(13, pixelIndexWord, tableCodeword1, baseColorSubblock1, pixelBuffer);
                ProcessPixelEtc2Punchthrough(14, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
                ProcessPixelEtc2Punchthrough(15, pixelIndexWord, tableCodeword2, baseColorSubblock2, pixelBuffer);
            }
        }

        private static unsafe void ProcessBlockEtc2PunchthroughTOrHMode(byte* bitString,
            EtcMode etcMode, byte* pixelBuffer)
        {
            int baseColor1R, baseColor1G, baseColor1B;
            int baseColor2R, baseColor2G, baseColor2B;
            int* paintColorR = stackalloc int[4],
                paintColorG = stackalloc int[4],
                paintColorB = stackalloc int[4];

            int distance;
            if (etcMode == EtcMode.EtcT)
            {
                // T mode.
                baseColor1R = ((bitString[0] & 0x18) >> 1) | (bitString[0] & 0x3);
                baseColor1R |= baseColor1R << 4;
                baseColor1G = bitString[1] & 0xF0;
                baseColor1G |= baseColor1G >> 4;
                baseColor1B = bitString[1] & 0x0F;
                baseColor1B |= baseColor1B << 4;
                baseColor2R = bitString[2] & 0xF0;
                baseColor2R |= baseColor2R >> 4;
                baseColor2G = bitString[2] & 0x0F;
                baseColor2G |= baseColor2G << 4;
                baseColor2B = bitString[3] & 0xF0;
                baseColor2B |= baseColor2B >> 4;
                // index = (da << 1) | db
                distance = Etc2DistanceTable[((bitString[3] & 0x0C) >> 1) | (bitString[3] & 0x1)];
                paintColorR[0] = baseColor1R;
                paintColorG[0] = baseColor1G;
                paintColorB[0] = baseColor1B;
                paintColorR[2] = baseColor2R;
                paintColorG[2] = baseColor2G;
                paintColorB[2] = baseColor2B;
                paintColorR[1] = Clamp(baseColor2R + distance);
                paintColorG[1] = Clamp(baseColor2G + distance);
                paintColorB[1] = Clamp(baseColor2B + distance);
                paintColorR[3] = Clamp(baseColor2R - distance);
                paintColorG[3] = Clamp(baseColor2G - distance);
                paintColorB[3] = Clamp(baseColor2B - distance);
            }
            else
            {
                // H mode.
                baseColor1R = (bitString[0] & 0x78) >> 3;
                baseColor1R |= baseColor1R << 4;
                baseColor1G = ((bitString[0] & 0x07) << 1) | ((bitString[1] & 0x10) >> 4);
                baseColor1G |= baseColor1G << 4;
                baseColor1B = (bitString[1] & 0x08) | ((bitString[1] & 0x03) << 1) | ((bitString[2] & 0x80) >> 7);
                baseColor1B |= baseColor1B << 4;
                baseColor2R = (bitString[2] & 0x78) >> 3;
                baseColor2R |= baseColor2R << 4;
                baseColor2G = ((bitString[2] & 0x07) << 1) | ((bitString[3] & 0x80) >> 7);
                baseColor2G |= baseColor2G << 4;
                baseColor2B = (bitString[3] & 0x78) >> 3;
                baseColor2B |= baseColor2B << 4;
                // da is most significant bit, db is middle bit, least significant bit is
                // (base_color1 value >= base_color2 value).
                int baseColor1Value = (baseColor1R << 16) + (baseColor1G << 8) + baseColor1B;
                int baseColor2Value = (baseColor2R << 16) + (baseColor2G << 8) + baseColor2B;
                int bit = baseColor1Value >= baseColor2Value ? 1 : 0;
                distance = Etc2DistanceTable[(bitString[3] & 0x04) | ((bitString[3] & 0x01) << 1) | bit];
                paintColorR[0] = Clamp(baseColor1R + distance);
                paintColorG[0] = Clamp(baseColor1G + distance);
                paintColorB[0] = Clamp(baseColor1B + distance);
                paintColorR[1] = Clamp(baseColor1R - distance);
                paintColorG[1] = Clamp(baseColor1G - distance);
                paintColorB[1] = Clamp(baseColor1B - distance);
                paintColorR[2] = Clamp(baseColor2R + distance);
                paintColorG[2] = Clamp(baseColor2G + distance);
                paintColorB[2] = Clamp(baseColor2B + distance);
                paintColorR[3] = Clamp(baseColor2R - distance);
                paintColorG[3] = Clamp(baseColor2G - distance);
                paintColorB[3] = Clamp(baseColor2B - distance);
            }

            uint pixelIndexWord = ((uint)bitString[4] << 24) | ((uint)bitString[5] << 16) |
                                  ((uint)bitString[6] << 8) | bitString[7];

            uint* buffer = (uint*)pixelBuffer;
            for (int i = 0; i < 16; i++)
            {
                int pixelIndex = (int)((pixelIndexWord & (1 << i)) >> i); // Least significant bit.
                pixelIndex |= (int)((pixelIndexWord & (0x10000 << i)) >> (16 + i - 1)); // Most significant bit.
                int r = paintColorR[pixelIndex];
                int g = paintColorG[pixelIndex];
                int b = paintColorB[pixelIndex];
                uint mask = PunchthroughMaskTable[pixelIndex];
                buffer[(i & 3) * 4 + ((i & 12) >> 2)] = Rgba((byte)r, (byte)g, (byte)b, 0xff) &
                                                        (BitConverter.IsLittleEndian
                                                            ? mask
                                                            : BinaryPrimitives.ReverseEndianness(mask));
            }
        }

        /// <summary>
        /// Decompress a 64-bit 4x4 pixel texture block compressed using the ETC2_PUNCHTROUGH format.
        /// </summary>
        /// <param name="bitString"></param>
        /// <param name="etc"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEtc2Punchthrough(byte* bitString, EtcMode etc,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            int r = bitString[0] & 0xF8;
            r += Complement3Bitshifted(bitString[0] & 7);
            int g = bitString[1] & 0xF8;
            g += Complement3Bitshifted(bitString[1] & 7);
            int b = bitString[2] & 0xF8;
            b += Complement3Bitshifted(bitString[2] & 7);

            bool opaque = (bitString[3] & 2) != 0;
            if (opaque && (flags & DecompressionFunctionFlags.NonOpaqueOnly) != 0)
                return false;
            if (!opaque && (flags & DecompressionFunctionFlags.OpaqueOnly) != 0)
                return false;
            if ((r & 0xFF07) != 0)
            {
                // T mode.
                if ((etc & EtcMode.EtcT) == 0)
                    return false;
                if (opaque)
                {
                    ProcessBlockEtc2TOrHMode(bitString, EtcMode.EtcT,
                        pixelBuffer);
                    return true;
                }

                // T mode with punchthrough alpha.
                ProcessBlockEtc2PunchthroughTOrHMode(bitString,
                    EtcMode.EtcT, pixelBuffer);
                return true;
            }

            if ((g & 0xFF07) != 0)
            {
                // H mode.
                if ((etc & EtcMode.EtcH) == 0)
                    return false;
                if (opaque)
                {
                    ProcessBlockEtc2TOrHMode(bitString, EtcMode.EtcH,
                        pixelBuffer);
                    return true;
                }

                // H mode with punchthrough alpha.
                ProcessBlockEtc2PunchthroughTOrHMode(bitString, EtcMode.EtcH,
                    pixelBuffer);
                return true;
            }

            if ((b & 0xFF07) != 0)
            {
                // Planar mode.
                if ((etc & EtcMode.EtcPlanar) == 0)
                    return false;
                // Opaque always set.
                if ((flags & DecompressionFunctionFlags.NonOpaqueOnly) != 0)
                    return false;
                ProcessBlockEtc2PlanarMode(bitString, pixelBuffer);
                return true;
            }

            // Differential mode.
            if (opaque)
                return DecompressBlockEtc1(bitString, etc, flags,
                    pixelBuffer);
            // Differential mode with punchthrough alpha.
            if ((etc & EtcMode.EtcDifferential) == 0)
                return false;
            ProcessBlockEtc2PunchthroughDifferentialMode(bitString, pixelBuffer);
            return true;
        }


        /// <summary>
        /// Return the internal mode of a ETC2_PUNCHTROUGH block.
        /// </summary>
        /// <param name="bitString"></param>
        /// <returns></returns>
        public static unsafe EtcMode GetModeEtc2Punchthrough(byte* bitString)
        {
            // Figure out the mode.
            //	int opaque = bitString[3] & 2;
            int r = bitString[0] & 0xF8;
            r += Complement3Bitshifted(bitString[0] & 7);
            int g = bitString[1] & 0xF8;
            g += Complement3Bitshifted(bitString[1] & 7);
            int b = bitString[2] & 0xF8;
            b += Complement3Bitshifted(bitString[2] & 7);
            if ((r & 0xFF07) != 0)
                return EtcMode.EtcT;
            if ((g & 0xFF07) != 0)
                return EtcMode.EtcH;
            if ((b & 0xFF07) != 0)
                return EtcMode.EtcPlanar;
            return EtcMode.EtcDifferential;
        }

        private static unsafe void SetModeEtc2Punchthrough(byte* bitString, EtcMode etcMode,
            DecompressionFunctionFlags flags)
        {
            if ((flags & DecompressionFunctionFlags.NonOpaqueOnly) != 0)
                bitString[3] &= unchecked((byte)~0x2);
            if ((flags & DecompressionFunctionFlags.OpaqueOnly) != 0)
                bitString[3] |= 0x2;
            SetModeEtc2Thp(bitString, etcMode, flags);
        }

        private static readonly sbyte[,] EacModifierTable =
        {
            {-3, -6, -9, -15, 2, 5, 8, 14}, {-3, -7, -10, -13, 2, 6, 9, 12}, {-2, -5, -8, -13, 1, 4, 7, 12},
            {-2, -4, -6, -13, 1, 3, 5, 12}, {-3, -6, -8, -12, 2, 5, 7, 11}, {-3, -7, -9, -11, 2, 6, 8, 10},
            {-4, -7, -8, -11, 3, 6, 7, 10}, {-3, -5, -8, -11, 2, 4, 7, 10}, {-2, -6, -8, -10, 1, 5, 7, 9},
            {-2, -5, -8, -10, 1, 4, 7, 9}, {-2, -4, -8, -10, 1, 3, 7, 9}, {-2, -5, -7, -10, 1, 4, 6, 9},
            {-3, -4, -7, -10, 2, 3, 6, 9}, {-1, -2, -3, -10, 0, 1, 2, 9}, {-4, -6, -8, -9, 3, 5, 7, 8},
            {-3, -5, -7, -9, 2, 4, 6, 8}
        };

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void ProcessPixelEac(byte i, ulong pixels, sbyte* modifierTable, int baseCodeword,
            int multiplier, byte* pixelBuffer)
        {
            int modifier = modifierTable[(pixels >> (45 - i * 3)) & 7];
            pixelBuffer[((i & 3) * 4 + ((i & 12) >> 2)) * 4 + 3] =
                Clamp(baseCodeword + modifier * multiplier);
        }

        /// <summary>
        /// Decompress a 128-bit 4x4 pixel texture block compressed using the ETC2_EAC format.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <param name="modeMask"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEtc2Eac(byte* bitstring, EtcMode modeMask,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            bool r = DecompressBlockEtc2(&bitstring[8], modeMask, flags, pixelBuffer);
            if (!r)
                return false;
            // Decode the alpha part.
            int baseCodeword = bitstring[0];
            fixed (sbyte* modifierTableB = EacModifierTable)
            {
                sbyte* modifierTable = modifierTableB + (bitstring[1] & 0x0F) * 8;
                int multiplier = (bitstring[1] & 0xF0) >> 4;
                if (multiplier == 0 && (flags & DecompressionFunctionFlags.Encode) != DecompressionFunctionFlags.Encode)
                    // Not allowed in encoding. Decoder should handle it.
                    return false;
                ulong pixels = ((ulong)bitstring[2] << 40) | ((ulong)bitstring[3] << 32) |
                               ((ulong)bitstring[4] << 24)
                               | ((ulong)bitstring[5] << 16) | ((ulong)bitstring[6] << 8) | bitstring[7];
                ProcessPixelEac(0, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(1, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(2, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(3, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(4, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(5, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(6, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(7, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(8, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(9, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(10, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(11, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(12, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(13, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(14, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                ProcessPixelEac(15, pixels, modifierTable, baseCodeword, multiplier, pixelBuffer);
                return true;
            }
        }

        /// <summary>
        /// Return the internal mode of a ETC2_EAC block.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <returns></returns>
        public static unsafe EtcMode GetModeEtc2Eac(byte* bitstring)
        {
            return GetModeEtc2(&bitstring[8]);
        }

        public static unsafe void SetModeETC2_EAC(byte* bitstring, EtcMode mode, DecompressionFunctionFlags flags)
        {
            SetModeEtc2(&bitstring[8], mode, flags);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Clamp0To2047(int x)
        {
            if (x < 0)
                return 0;
            if (x > 2047)
                return 2047;
            return (uint)x;
        }


        /// <summary>
        /// For each pixel, decode an 11-bit integer and store as follows:
        /// If shift and offset are zero, store each value in consecutive 16 bit values in pixel_buffer.
        /// If shift is one, store each value in consecutive 32-bit words in pixel_buffer; if offset
        /// is zero, store it in the first 16 bits, if offset is one store it in the last 16 bits of each
        /// 32-bit word.
        /// </summary>
        /// <param name="qword"></param>
        /// <param name="shift"></param>
        /// <param name="offset"></param>
        /// <param name="pixelBuffer"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void DecodeBlockEac11Bit(ulong qword, int shift, int offset, byte* pixelBuffer)
        {
            int baseCodewordTimes8Plus4 = (int)(((qword & 0xFF00000000000000) >> (56 - 3)) | 0x4);
            int modifierIndex = (int)((qword & 0x000F000000000000) >> 48);
            fixed (sbyte* modifierTableB = EacModifierTable)
            {
                sbyte* modifierTable = modifierTableB + modifierIndex * 8;
                int multiplierTimes8 = (int)((qword & 0x00F0000000000000) >> (52 - 3));
                if (multiplierTimes8 == 0)
                    multiplierTimes8 = 1;
                ushort* buffer = (ushort*)pixelBuffer;
                for (int i = 0; i < 16; i++)
                {
                    int pixelIndex = (int)((qword & (ulong)(0x0000E00000000000 >> (i * 3))) >> (45 - i * 3));
                    int modifier = modifierTable[pixelIndex];
                    uint value = Clamp0To2047(baseCodewordTimes8Plus4 +
                                              modifier * multiplierTimes8);
                    buffer[(((i & 3) * 4 + ((i & 12) >> 2)) << shift) + offset] =
                        (ushort)((value << 5) | (value >> 6)); // Replicate bits to 16-bit.
                }
            }
        }

        /// <summary>
        /// Decompress a 64-bit 4x4 pixel texture block compressed using the
        /// EAC_R11 format.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <param name="modeMask"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEacR11(byte* bitstring, EtcMode modeMask,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            ulong qword = ((ulong)bitstring[0] << 56) | ((ulong)bitstring[1] << 48) |
                          ((ulong)bitstring[2] << 40) |
                          ((ulong)bitstring[3] << 32) | ((ulong)bitstring[4] << 24) |
                          ((ulong)bitstring[5] << 16) | ((ulong)bitstring[6] << 8) | bitstring[7];
            DecodeBlockEac11Bit(qword, 0, 0, pixelBuffer);
            return true;
        }

        /// <summary>
        /// Decompress a 128-bit 4x4 pixel texture block compressed using the
        /// EAC_RG11 format.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <param name="modeMask"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEacRg11(byte* bitstring, EtcMode modeMask,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            ulong redQword = ((ulong)bitstring[0] << 56) | ((ulong)bitstring[1] << 48) |
                             ((ulong)bitstring[2] << 40) |
                             ((ulong)bitstring[3] << 32) | ((ulong)bitstring[4] << 24) |
                             ((ulong)bitstring[5] << 16) | ((ulong)bitstring[6] << 8) | bitstring[7];
            DecodeBlockEac11Bit(redQword, 1, 0, pixelBuffer);
            ulong greenQword = ((ulong)bitstring[8] << 56) | ((ulong)bitstring[9] << 48) |
                               ((ulong)bitstring[10] << 40) |
                               ((ulong)bitstring[11] << 32) | ((ulong)bitstring[12] << 24) |
                               ((ulong)bitstring[13] << 16) | ((ulong)bitstring[14] << 8) | bitstring[15];
            DecodeBlockEac11Bit(greenQword, 1, 1, pixelBuffer);
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int ClampMinus1023To1023(int x)
        {
            if (x < -1023)
                return -1023;
            if (x > 1023)
                return 1023;
            return x;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ushort ReplicateSigned11BitsTo16Bits(int value)
        {
            if (value >= 0)
                return (ushort)((value << 5) | (value >> 5));
            value = -value;
            value = (value << 5) | (value >> 5);
            return (ushort)-value;
        }


//
        /// <summary>
        /// For each pixel, decode an 11-bit signed integer and store as follows:
        /// If shift and offset are zero, store each value in consecutive 16 bit values in pixel_buffer.
        /// If shift is one, store each value in consecutive 32-bit words in pixel_buffer; if offset
        /// is zero, store it in the first 16 bits, if offset is one store it in the last 16 bits of each
        /// 32-bit word.
        /// </summary>
        /// <param name="qword"></param>
        /// <param name="shift"></param>
        /// <param name="offset"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool DecodeBlockEacSigned11Bit(ulong qword, int shift, int offset, byte* pixelBuffer)
        {
            int baseCodeword = (sbyte)((qword & 0xFF00000000000000) >> 56); // Signed 8 bits.
            if (baseCodeword == -128)
                // Not allowed in encoding. Decoder should handle it but we don't do that yet.
                return false;
            int baseCodewordTimes8 = baseCodeword << 3; // Arithmetic shift.
            int modifierIndex = (int)((qword & 0x000F000000000000) >> 48);
            fixed (sbyte* modifierTableB = EacModifierTable)
            {
                sbyte* modifierTable = modifierTableB + modifierIndex * 8;
                int multiplierTimes8 = (int)((qword & 0x00F0000000000000) >> (52 - 3));
                if (multiplierTimes8 == 0)
                    multiplierTimes8 = 1;
                ushort* buffer = (ushort*)pixelBuffer;
                for (int i = 0; i < 16; i++)
                {
                    int pixelIndex = (int)((qword & (ulong)(0x0000E00000000000 >> (i * 3))) >> (45 - i * 3));
                    int modifier = modifierTable[pixelIndex];
                    int value = ClampMinus1023To1023(baseCodewordTimes8 +
                                                     modifier * multiplierTimes8);
                    buffer[(((i & 3) * 4 + ((i & 12) >> 2)) << shift) + offset] = ReplicateSigned11BitsTo16Bits(value);
                }

                return true;
            }
        }

        /// <summary>
        /// Decompress a 64-bit 4x4 pixel texture block compressed using the EAC_SIGNED_R11 format.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <param name="modeMask"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEacSignedR11(byte* bitstring, EtcMode modeMask,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            ulong qword = ((ulong)bitstring[0] << 56) | ((ulong)bitstring[1] << 48) |
                          ((ulong)bitstring[2] << 40) |
                          ((ulong)bitstring[3] << 32) | ((ulong)bitstring[4] << 24) |
                          ((ulong)bitstring[5] << 16) | ((ulong)bitstring[6] << 8) | bitstring[7];
            return DecodeBlockEacSigned11Bit(qword, 0, 0, pixelBuffer);
        }

        /// <summary>
        /// Decompress a 128-bit 4x4 pixel texture block compressed using the EAC_SIGNED_RG11 format.
        /// </summary>
        /// <param name="bitstring"></param>
        /// <param name="modeMask"></param>
        /// <param name="flags"></param>
        /// <param name="pixelBuffer"></param>
        /// <returns></returns>
        public static unsafe bool DecompressBlockEacSignedRg11(byte* bitstring, EtcMode modeMask,
            DecompressionFunctionFlags flags, byte* pixelBuffer)
        {
            ulong redQword = ((ulong)bitstring[0] << 56) | ((ulong)bitstring[1] << 48) |
                             ((ulong)bitstring[2] << 40) |
                             ((ulong)bitstring[3] << 32) | ((ulong)bitstring[4] << 24) |
                             ((ulong)bitstring[5] << 16) | ((ulong)bitstring[6] << 8) | bitstring[7];
            bool r = DecodeBlockEacSigned11Bit(redQword, 1, 0, pixelBuffer);
            if (!r)
                return false;
            ulong greenQword = ((ulong)bitstring[8] << 56) | ((ulong)bitstring[9] << 48) |
                               ((ulong)bitstring[10] << 40) |
                               ((ulong)bitstring[11] << 32) | ((ulong)bitstring[12] << 24) |
                               ((ulong)bitstring[13] << 16) | ((ulong)bitstring[14] << 8) | bitstring[15];
            return DecodeBlockEacSigned11Bit(greenQword, 1, 1, pixelBuffer);
        }
    }
}

namespace Fp
{
    public partial class Processor
    {
        /// <summary>
        /// Decode ETC2-compressed image
        /// </summary>
        /// <param name="src">Source buffer</param>
        /// <param name="img">Target buffer</param>
        /// <param name="width">Output width</param>
        /// <param name="height">Output height</param>
        /// <param name="hasAlpha">Image has alpha channel</param>
        /// <returns>True if succeeded</returns>
        public static unsafe bool DecodeEtc2(Span<byte> src, Span<uint> img, int width, int height, bool hasAlpha)
        {
            int w = (width + 3) / 4 * 4;
            int h = (height + 3) / 4 * 4;

            fixed (byte* bsrc = &src.GetPinnableReference())
            {
                byte* srcP = hasAlpha ? bsrc + 64 / 8 : bsrc;
                fixed (uint* pImg = &img.GetPinnableReference())
                {
                    uint* tar = stackalloc uint[4 * 4];
                    byte* tar2 = (byte*)tar;
                    for (int y = 0; y < h / 4; y++)
                    {
                        for (int x = 0; x < w / 4; x++)
                        {
                            bool res;
                            res = EtcDecoder.DecompressBlockEtc2(srcP, EtcDecoder.EtcMode.AllModesEtc2,
                                EtcDecoder.DecompressionFunctionFlags.None, tar2);
                            if (!res) return false;
                            if (hasAlpha)
                            {
                                res = EtcDecoder.DecompressBlockEtc2Eac(srcP - 64 / 8, EtcDecoder.EtcMode.AllModesEtc2,
                                    EtcDecoder.DecompressionFunctionFlags.None, tar2);
                                if (!res) return false;
                            }

                            for (int yy = 0; yy < 4; yy++)
                            {
                                for (int xx = 0; xx < 4; xx++)
                                {
                                    if (x * 4 + xx >= width || y * 4 + yy >= height) continue;
                                    pImg[(y * 4 + yy) * width + x * 4 + xx] = tar[yy * 4 + xx];
                                }
                            }

                            srcP += hasAlpha ? 128 / 8 : 64 / 8;
                        }
                    }
                }
            }

            return true;
        }
    }
}
